// //;

//

// import React, { useEffect, useState } from "react";
// import supabase from "@/app/api/supabaseClient";
// import Image from "next/image";
// import { useDispatch } from "react-redux";
// import { Button } from "../../ui/button";
// import { useRouter } from "next/navigation";
// import Navbar from "../../myComponents/Navbar";
// import { toast } from "react-hot-toast";

// const WelcomePage = () => {
//    // const currentUser = useSelector((state: RootState) => state.authSlice.user);
//    const [isSubmitting, setIsSubmitting] = useState(false);
//    const [email, setEmail] = useState<string | undefined>("");
//    const [user, setUser] = useState<User | null>(null);
//    const [image, setImage] = useState("");
//    const [name, setName] = useState("");
//    const [userId, setUserId] = useState("");
//    const dispatch = useDispatch();
//    const router = useRouter();

//    const logOff = async () => {
//       setIsSubmitting(true);
//       try {
//          const { error } = await supabase.auth.signOut();

//          if (error) {
//             console.error("Error signing out:", error);
//          } else {
//             toast.success("logged out successfully!");
//             window.location.href = "/onboard";
//          }
//       } catch (error) {
//          console.error("Error signing out:", error);
//       }
//    };

//    return (
//       <main>
//           
//          <div className="pt-150px">
//             <h1>Welcome!</h1>
//             <Image
//                src={image}
//                alt="user-image"
//                width={200}
//                height={200}
//                className="object-cover rounded-full"
//                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 70vw, 33vw"
//             />
//             <p>
//                Thank you for creating an account {name}. Please check your inbox
//                at {email} and click the link we sent to complete your account
//                set-up.
//             </p>
//             <Button>Click here to resend the email</Button>
//             <Button
//                disabled={isSubmitting}
//                variant="destructive"
//                onClick={logOff}>
//                logout
//             </Button>
//             current user: {email}
//             current user: {userId}
//          </div>
//       </main>
//    );
// };

// export default WelcomePage;

// import { createMiddlewareClient } from "@supabase/auth-helpers-nextjs";
// import { NextResponse } from "next/server";

// import type { NextRequest } from "next/server";

// export async function middleware(req: NextRequest) {
//    const res = NextResponse.next();
//    const supabase = createMiddlewareClient({ req, res });

//    const {
//       data: { user },
//    } = await supabase.auth.getUser();

//    // if user is signed in and the current path is / redirect the user to /account
//    if (user && req.nextUrl.pathname === "/") {
//       return NextResponse.redirect(new URL("/account", req.url));
//    }

//    // if user is not signed in and the current path is not / redirect the user to /
//    if (!user && req.nextUrl.pathname !== "/") {
//       return NextResponse.redirect(new URL("/", req.url));
//    }

//    return res;
// }

// export const config = {
//    matcher: ["/", "/account"],
// };


   // // useEffect(() => {
   // //    const fetchUserHashtags = async () => {
   // //       try {
   // //          if (userId) {
   // //             // Fetch user-related hashtags
   // //             const { data, error } = await supabase
   // //                .from("user_hashtags")
   // //                .select("hashtag_id")
   // //                .eq("user_id", userId);

   // //             if (error) {
   // //                console.error("Error fetching user hashtags:", error.message);
   // //             } else {
   // //                const hashtagIds = data.map(
   // //                   (userHashtag) => userHashtag.hashtag_id
   // //                );

   // //                // Fetch the names of user-related hashtags from the hashtags table
   // //                const { data: hashtagsData, error: hashtagsError } =
   // //                   await supabase
   // //                      .from("hashtags")
   // //                      .select("name")
   // //                      .in("id", hashtagIds);

   // //                if (hashtagsError) {
   // //                   console.error(
   // //                      "Error fetching hashtag names:",
   // //                      hashtagsError.message
   // //                   );
   // //                } else {
   // //                   setUserHashtags(
   // //                      hashtagsData.map((hashtag) => hashtag.name)
   // //                   );
   // //                }
   // //             }
   // //          }
   // //       } catch (error: any) {
   // //          console.error("Error:", error.message);
   // //       }
   // //    };

   //    // Call the fetchUserHashtags function when the component mounts
   //    fetchUserHashtags();
   // }, [userId]); // Only run this effect when userId changes







   // <ul className="flex flex-col gap-7">
//                {userHashtags?.map((hashtag: HashtagProp, i: number) => {
//                   const { name, hashtag_id } = hashtag;
//                   return (
//                      <Button key={i} to={`/hashtags/${hashtag_id}`}>
//                         <li className={`${buttonVariants}`}>{name}</li>
//                      </Button>
//                   );
//                })}
//             </ul>
//             <div className="py-20">
//                <Button onClick={logOff} disabled={loggingOut}>
//                   Log Out
//                </Button>
// </div>

// const logOff = async () => {
//    setLoggingOut(true);
//    try {
//       const { error } = await supabase.auth.signOut();

//       if (error) {
//          console.error("Error signing out:", error);
//       } else {
//          navigate("/");
//       }
//    } catch (error) {
//       console.error("Error signing out:", error);
//    }
// };





// import { useEffect, useState } from "react";
// import { motion } from "framer-motion";
// import supabase from "../../lib/supabaseClient";
// import PostCard from "./PostCard";
// import useCachedPosts, { usePost } from "../../hooks/usePost";
// import { Post } from "../../../types";

// interface PostCardProps {
//    author: string;
//    id: string;
//    image: string;
//    snippet: string;
//    author_verification: boolean;
//    title: string;
//    created_at: string;
//    category_name: string;
//    author_image: string;
//    bookmark_count: number;
//    likes_count: number;
//    comment_count: number;
//    profile_id: string;
// }

// export default function HomeCard() {
//    const { posts: blogposts, isLoading: blogLoading } = useCachedPosts();
//    const [posts, setPosts] = useState<PostCardProps[]>([]);
//    const [isLoading, setIsLoading] = useState(false);
//    const [error, setError] = useState<string | null>(null);
//    const [totalPosts, setTotalPosts] = useState<number | null>(null); // Total number of posts
//    console.log(posts?.length);
//    console.log(totalPosts);

//    // Function to fetch the total number of posts
//    const fetchTotalPosts = async () => {
//       try {
//          const { count, error } = await supabase
//             .from("posts")
//             .select("count", { count: "exact" });

//          if (!error) {
//             setTotalPosts(count); // Set the total number of posts
//          } else {
//             setError(
//                "An error occurred while fetching the total number of posts."
//             );
//          }
//       } catch (error) {
//          setError(
//             "An error occurred while fetching the total number of posts."
//          );
//       }
//    };

//    useEffect(() => {
//       // Fetch the total number of posts when the component mounts
//       fetchTotalPosts();
//    }, []);
//    useEffect(() => {
//       setPosts(blogposts as Post[]);
//    }, []);

//    // useEffect(() => {
//    //    const fetchInitialPosts = async () => {
//    //       try {
//    //          const { data, error } = await supabase
//    //             .from("posts")
//    //             .select("*")
//    //             .range(0, 9)
//    //             .order("created_at", { ascending: false });

//    //          if (!error && data) {
//    //             setPosts(data);
//    //          } else {
//    //             setError("An error occurred while fetching posts.");
//    //          }
//    //       } catch (error) {
//    //          setError("An error occurred while fetching posts.");
//    //       }
//    //    };

//    //    fetchInitialPosts();
//    // }, []);

//    const fetchMorePosts = async () => {
//       setIsLoading(true);
//       try {
//          const from = posts.length;
//          const to = from + 10;

//          const { data, error } = await supabase
//             .from("posts")
//             .select("*")
//             .range(from, to)
//             .order("created_at", { ascending: false });

//          if (!error && data) {
//             // Update the posts state by appending the new data
//             setPosts((prevPosts) => [...prevPosts, ...data]);
//          } else {
//             setError("An error occurred while fetching more posts.");
//          }
//       } catch (error) {
//          setError("An error occurred while fetching more posts.");
//       } finally {
//          setIsLoading(false);
//       }
//    };

//    const handleLoadMoreClick = () => {
//       fetchMorePosts();
//    };
//    // // Fetch more posts
//    // const fetchMorePosts = async () => {
//    //    if (isFetching) {
//    //       return; // If already fetching, do nothing
//    //    }

//    //    setIsFetching(true);

//    //    try {
//    //       const from = nextPage * PAGE_COUNT; // Calculate the offset
//    //       const to = from + PAGE_COUNT - 1;
//    //       const { data, error } = await supabase
//    //          .from("posts")
//    //          .select("*")
//    //          .range(from, to)
//    //          .order("created_at", { ascending: true });

//    //       if (!error) {
//    //          if (data && data.length > 0) {
//    //             setPosts((prevPosts) => [...prevPosts, ...data]);
//    //             setNextPage((prev) => prev + 1);

//    //             console.log("fetching from :", from);
//    //             console.log("to", to);
//    //             console.log(from);
//    //          } else {
//    //             setError("No more posts to fetch.");
//    //          }
//    //       } else {
//    //          setError("An error occurred while fetching more posts.");
//    //       }
//    //    } catch (error) {
//    //       setError("An error occurred while fetching more posts.");
//    //    } finally {
//    //       setIsFetching(false); // Set isFetching to false after fetching is complete
//    //    }
//    // };

//    // // Load more posts when reaching the bottom
//    // useEffect(() => {
//    //    const handleScroll = () => {
//    //       if (
//    //          window.innerHeight + document.documentElement.scrollTop ===
//    //          document.documentElement.offsetHeight
//    //       ) {
//    //          fetchMorePosts();
//    //       }
//    //    };

//    //    window.addEventListener("scroll", handleScroll);

//    //    return () => {
//    //       window.removeEventListener("scroll", handleScroll);
//    //    };
//    //    // eslint-disable-next-line react-hooks/exhaustive-deps
//    // }, []);

//    return (
//       <>
//          <div className="flex flex-col w-full">
//             {posts?.map((post, index) => {
//                const {
//                   author,
//                   id,
//                   image,
//                   snippet,
//                   author_verification,
//                   title,
//                   created_at,
//                   profile_id,
//                   category_name,
//                   author_image,
//                   bookmark_count,
//                   likes_count,
//                   comment_count,
//                } = post;

//                return (
//                   <motion.div
//                      key={post.id}
//                      initial={{ opacity: 0, y: 20 }}
//                      animate={{ opacity: 1, y: 0 }}
//                      transition={{
//                         duration: 0,
//                         ease: [0.25, 0.25, 0, 1],
//                         delay: index / 15, // Adjust the delay as needed
//                      }}>
//                      <PostCard
//                         key={id}
//                         author={author}
//                         id={id}
//                         image={image}
//                         snippet={snippet}
//                         author_verification={author_verification}
//                         title={title}
//                         category_name={category_name}
//                         author_image={author_image}
//                         bookmark_count={bookmark_count}
//                         created_at={created_at}
//                         likes_count={likes_count}
//                         comment_count={comment_count}
//                         profile_id={profile_id}
//                      />
//                   </motion.div>
//                );
//             })}
//             {isLoading && <div>Loading...</div>}
//             {error && (
//                <div className="fixed inset-0 flex items-center justify-center bg-white">
//                   <div className="relative w-full md:w-[500px] h-[500px]">
//                      <img
//                         src="/internalerror.svg"
//                         alt="loading-image"
//                         className="object-cover"
//                      />
//                   </div>
//                </div>
//             )}
//             {totalPosts !== null && totalPosts > posts?.length && (
//                <div className="mb-10">
//                   <button
//                      onClick={handleLoadMoreClick}
//                      className="w-full px-5 py-2 mt-5 font-semibold md:w-auto bg-accent-red hover:bg-wh-500 text-wh-10 dark:text-black">
//                      Load More
//                   </button>
//                </div>
//             )}
//          </div>
//       </>
//    );
// }





               <TooltipProvider>
                  <Tooltip>
                     <TooltipTrigger>
                        <p
                           className="hidden cursor-pointer md:block"
                           onClick={() => navigate("/search")}>
                           <Search className="w-6 h-6 opacity-50" />
                        </p>
                     </TooltipTrigger>
                     <TooltipContent>
                        <p>Search</p>
                     </TooltipContent>
                  </Tooltip>
               </TooltipProvider>



               <div className="w-full px-6 py-4 border-b border-black/10 dark:border-white/10" />

                <button className="flex items-center px-2 py-2 text-xs font-normal transition-transform duration-300 bg-black rounded-full hover:scale-105 w-max whitespace-nowrap dark:bg-white text-black ">
                                 {name}
                              </button>






                              import { useEffect, useState } from "react";
import { useSingleHashtag } from "../../hooks/useFetchSingleHashtag";
import { useParams } from "react-router-dom";
import supabase from "../../lib/supabaseClient";
import { useFetchUser } from "../../hooks/useFetchUser";

const Topics = () => {
   const [hashtagId, setHashtagId] = useState<string | null | undefined>(null);
   const [hashtagName, setHashtagName] = useState<string | null | undefined>(
      null
   );
   const [subtopic, setSubtopic] = useState<
      Array<{ name: string; description: string; id: string }>
   >([]);
   const [subSubTopic, setSubSubTopic] = useState<Array<{
      name: string;
      description: string;
      id: string;
   }> | null>([]);
   const { id } = useParams();
   const { user } = useFetchUser();
   const userId = user?.id;
   const [isFollowing, setIsFollowing] = useState(false);

   const { hashtag: hashtagData } = useSingleHashtag(id as string);

   useEffect(() => {
      setHashtagId(hashtagData?.id);
      setHashtagName(hashtagData?.name);
   }, [hashtagData]);

   useEffect(() => {
      const fetchSubtopic = async () => {
         const { data, error } = await supabase
            .from("subtopics")
            .select("*")
            .eq("parent_topic_id", hashtagId);

         if (data && !error) {
            setSubtopic(data);

            // After setting the subtopics, you can query related subsubtopics
            const subtopicIds = data.map((subtopic) => subtopic.id);

            const { data: subSubData, error: subSubError } = await supabase
               .from("subsubtopics")
               .select("*")
               .in("parent_subtopic_id", subtopicIds);

            if (subSubData && !subSubError) {
               setSubSubTopic(subSubData);
            }
         }
      };
      fetchSubtopic();
   }, [hashtagId]);
   // Check if the user is already following the topic
   // useEffect(() => {
   //    async function checkIsFollowing() {
   //       const { data, error } = await supabase
   //          .from("topicfellowship")
   //          .select()
   //          .eq("user_id", userId)
   //          .eq("topic_id", hashtagId)
   //          .single();

   //       if (data) {
   //          setIsFollowing(true);
   //       } else {
   //          setIsFollowing(false);
   //       }
   //    }

   //    checkIsFollowing();
   // }, [userId, hashtagId]);

   async function followTopic(type: string) {
      try {
         if (isFollowing) {
            // If the user is already following, unfollow the topic
            const { data, error } = await supabase
               .from("topicfellowship")
               .delete()
               .eq("user_id", userId)
               .eq("topic_id", hashtagId);

            if (!error) {
               // Record successfully deleted
               setIsFollowing(false);
               alert("You have unfollowed the topic.");
            } else {
               // Handle errors here, e.g., display an error message
               alert("Failed to unfollow the topic.");
               console.log(error);
            }
         } else {
            // If the user is not following, follow the topic
            const { data, error } = await supabase
               .from("topicfellowship")
               .insert([{ user_id: userId, topic_id: hashtagId, type }]);

            if (data && !error) {
               // Record successfully inserted
               setIsFollowing(true);
               alert("You are now following the topic.");
            } else {
               // Handle errors here, e.g., display an error message
               alert("Failed to follow the topic.");
               console.log(error);
            }
         }
      } catch (error) {
         console.error("An error occurred:", error);
      }
   }

   return (
      <main>
         <section>
            <div className="py-20 font-black">{hashtagName}</div>
            <button
               className="px-4 py-2 text-black border border-black bg-accent-orange"
               onClick={() => followTopic("Topic")}>
               {isFollowing ? "Unfollow" : "Follow"}
            </button>
            {isFollowing && <p>You are following this topic.</p>}

            {subtopic.map((topic) => (
               <div key={topic.id} className="flex flex-col gap-3 my-7">
                  <h1>{topic.name}</h1>
                  <p>{topic.description}</p>
                  <p className="pl-6">
                     {subSubTopic?.map((topic) => (
                        <div
                           key={topic.id}
                           className="flex flex-col items-center gap-3 my-7">
                           <h1>{topic.name}</h1>
                           <p>{topic.description}</p>
                        </div>
                     ))}
                  </p>
               </div>
            ))}
         </section>
      </main>
   );
};

export default Topics;




import { useEffect, useState } from "react";
import supabase from "../../lib/supabaseClient";

import { BiChevronUp } from "react-icons/bi";

const Topics = () => {
   const [topics, setTopics] = useState<
      Array<{ name: string; description: string; id: string }>
   >([]);
   const [subTopic, setSubTopic] = useState<
      Array<{ name: string; description: string; id: string }>
   >([]);
   const [subSubTopic, setSubSubTopic] = useState<Array<{
      name: string;
      description: string;
      id: string;
   }> | null>([]);

   useEffect(() => {
      const fetchData = async () => {
         const { data: topicsData, error: topicsError } = await supabase
            .from("topics")
            .select("*");

         if (topicsError) {
            console.error("Error fetching topics:", topicsError);
            return;
         }

         setTopics(topicsData);

         const topicIds = topicsData.map((topic) => topic.id);

         const { data: subtopicsData, error: subtopicsError } = await supabase
            .from("subtopics")
            .select("*")
            .in("parent_topic_id", topicIds);

         if (subtopicsError) {
            console.error("Error fetching subtopics:", subtopicsError);
            return;
         }

         setSubTopic(subtopicsData);

         const subtopicIds = subtopicsData.map((subtopic) => subtopic.id);

         const { data: subsubtopicsData, error: subsubtopicsError } =
            await supabase
               .from("subsubtopics")
               .select("*")
               .in("parent_subtopic_id", subtopicIds);

         if (subsubtopicsError) {
            console.error("Error fetching subsubtopics:", subsubtopicsError);
            return;
         }

         setSubSubTopic(subsubtopicsData);
      };

      fetchData();
   }, []);

   return (
      <main className="relative max-w-[1440px]">
         <section className="flex flex-col grid-cols-3 gap-6 px-6 md:gap-8 md:grid">
            {topics.map((topic) => (
               <div key={topic.id} className="col-span-1 ">
                  <div className="flex items-center justify-between w-full pb-3">
                     <h1 className="text-xl font-bold">{topic.name}</h1>
                     <BiChevronUp className="md:hidden" />
                  </div>
               </div>
            ))}
         </section>
         <p>
            <p className="pl-6">
               {subTopic?.map((topic) => (
                  <div
                     key={topic.id}
                     className="flex flex-col w-full gap-3 my-7">
                     <h1 className="text-sm font-semibold">{topic.name}</h1>
                     <BiChevronUp className="md:hidden" />
                  </div>
               ))}
            </p>
         </p>
         <p>
            <p className="pl-6">
               {subSubTopic?.map((topic) => (
                  <div
                     key={topic.id}
                     className="flex flex-col w-full gap-3 my-7">
                     <h1 className="text-sm">{topic.name}</h1>
                     <BiChevronUp className="md:hidden" />
                  </div>
               ))}
            </p>
         </p>
      </main>
   );
};

export default Topics;





<CategoryCard
                     isLoading={isLoading}
                     categoryPosts={categoryPosts}
                  />
                  {categoryPosts &&
                     totalCount !== null &&
                     categoryPosts.length < totalCount && (
                        <button
                           disabled={isFetching}
                           onClick={fetchMorePosts}
                           className={`${
                              isFetching && "bg-wh-300 animate-bounce"
                           } w-full px-5 py-2 mt-5 font-semibold md:w-auto bg-accent-red hover:bg-wh-500 text-wh-10 dark:text-black`}>
                           {isFetching ? "Loading More..." : " Load More"}
                        </button>
                     )}